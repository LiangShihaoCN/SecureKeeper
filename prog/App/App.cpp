/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Authors: Stefan Brenner, Colin Wulf
 */
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <unistd.h>
#include <pwd.h>
#define MAX_PATH FILENAME_MAX

#include "sgx_urts.h"
#include "App.h"
#include "Enclave_u.h"
#include <sgx_tcrypto.h>

#include <pthread.h>
#include <semaphore.h>

typedef struct _sgx_errlist_t {
	sgx_status_t err;
	const char *msg;
	const char *sug; /* Suggestion */
} sgx_errlist_t;

/* Error code returned by sgx_create_enclave */
static sgx_errlist_t sgx_errlist[] = { { SGX_ERROR_UNEXPECTED, "Unexpected error occurred.",
NULL }, { SGX_ERROR_INVALID_PARAMETER, "Invalid parameter.",
NULL }, { SGX_ERROR_OUT_OF_MEMORY, "Out of memory.",
NULL }, { SGX_ERROR_ENCLAVE_LOST, "Power transition occurred.",
		"Please refer to the sample \"PowerTransition\" for details." }, { SGX_ERROR_INVALID_ENCLAVE,
		"Invalid enclave image.",
		NULL }, { SGX_ERROR_INVALID_ENCLAVE_ID, "Invalid enclave identification.",
NULL }, { SGX_ERROR_INVALID_SIGNATURE, "Invalid enclave signature.",
NULL }, { SGX_ERROR_OUT_OF_EPC, "Out of EPC memory.",
NULL }, { SGX_ERROR_NO_DEVICE, "Invalid SGX device.",
		"Please make sure SGX module is enabled in the BIOS, and install SGX driver afterwards." }, {
		SGX_ERROR_MEMORY_MAP_CONFLICT, "Memory map conflicted.",
		NULL }, { SGX_ERROR_INVALID_METADATA, "Invalid enclave metadata.",
NULL }, { SGX_ERROR_DEVICE_BUSY, "SGX device was busy.",
NULL }, { SGX_ERROR_INVALID_VERSION, "Enclave version was invalid.",
NULL }, { SGX_ERROR_INVALID_ATTRIBUTE, "Enclave was not authorized.",
NULL }, { SGX_ERROR_ENCLAVE_FILE_ACCESS, "Can't open enclave file.",
NULL }, };

/* Check error conditions for loading enclave */
void print_error_message(sgx_status_t ret) {
	size_t idx = 0;
	size_t ttl = sizeof sgx_errlist / sizeof sgx_errlist[0];

	for (idx = 0; idx < ttl; idx++) {
		if (ret == sgx_errlist[idx].err) {
			if (NULL != sgx_errlist[idx].sug)
				printf("Info: %s\n", sgx_errlist[idx].sug);
			printf("Error: %s\n", sgx_errlist[idx].msg);
			break;
		}
	}

	if (idx == ttl)
		printf("Error: Unexpected error occurred.\n");
}

uint64_t initialize_enclave(void) {
	sgx_enclave_id_t eid = 0;

	/* Initialize the enclave:
	 *   Step 1: retrive the launch token saved by last transaction
	 *   Step 2: call sgx_create_enclave to initialize an enclave instance
	 *   Step 3: save the launch token if it is updated
	 */

	char token_path[MAX_PATH] = { '\0' };
	sgx_launch_token_t token = { 0 };
	sgx_status_t ret = SGX_ERROR_UNEXPECTED;
	int updated = 0;

	/* Step 1: retrive the launch token saved by last transaction */
	/* try to get the token saved in $HOME */
	const char *home_dir = getpwuid(getuid())->pw_dir;

	if (home_dir != NULL && (strlen(home_dir) + strlen("/") + sizeof(TOKEN_FILENAME) + 1) <= MAX_PATH) {
		/* compose the token path */
		strncpy(token_path, home_dir, strlen(home_dir));
		strncat(token_path, "/", strlen("/"));
		strncat(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME) + 1);
	} else {
		/* if token path is too long or $HOME is NULL */
		strncpy(token_path, TOKEN_FILENAME, sizeof(TOKEN_FILENAME));
	}

	FILE *fp = fopen(token_path, "rb");
	if (fp == NULL && (fp = fopen(token_path, "wb")) == NULL) {
		printf("Warning: Failed to create/open the launch token file \"%s\".\n", token_path);
	}

	if (fp != NULL) {
		/* read the token from saved file */
		size_t read_num = fread(token, 1, sizeof(sgx_launch_token_t), fp);
		if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {
			/* if token is invalid, clear the buffer */
			memset(&token, 0x0, sizeof(sgx_launch_token_t));
			printf("Warning: Invalid launch token read from \"%s\".\n", token_path);
		}
	}

	/* Step 2: call sgx_create_enclave to initialize an enclave instance */
	/* Debug Support: set 2nd parameter to 1 */
	ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &eid, NULL);
	if (ret != SGX_SUCCESS) {
		printf("SGX error Code %d.\n", ret);
		if (fp != NULL)
			fclose(fp);
		return -ret;
	}

	/* Step 3: save the launch token if it is updated */
	if (updated == FALSE || fp == NULL) {
		/* if the token is not updated, or file handler is invalid, do not perform saving */
		if (fp != NULL)
			fclose(fp);
		return eid;
	}

	/* reopen the file with write capablity */
	fp = freopen(token_path, "wb", fp);
	if (fp == NULL)
		return 0;
	size_t write_num = fwrite(token, 1, sizeof(sgx_launch_token_t), fp);
	if (write_num != sizeof(sgx_launch_token_t))
		printf("Warning: Failed to save launch token to \"%s\".\n", token_path);
	fclose(fp);
	return eid;
}

/* OCall functions */
void ocall_print(const char *str) {
	/* Proxy/Bridge will check the length and null-terminate
	 * the input string to prevent buffer overflow.
	 */
	printf("%s", str);
}

void hexDump(char *desc, void *addr, int len) {
	int i;
	unsigned char buff[17];
	unsigned char *pc = (unsigned char*) addr;

	// Output description if given.
	if (desc != NULL)
		printf("%s:\n", desc);

	// Process every byte in the data.
	for (i = 0; i < len; i++) {
		// Multiple of 16 means new line (with line offset).

		if ((i % 16) == 0) {
			// Just don't print ASCII for the zeroth line.
			if (i != 0)
				printf("  %s\n", buff);

			// Output the offset.
			printf("  %04x ", i);
		}

		// Now the hex code for the specific character.
		printf(" %02x", pc[i]);

		// And store a printable ASCII character for later.
		if ((pc[i] < 0x20) || (pc[i] > 0x7e))
			buff[i % 16] = '.';
		else
			buff[i % 16] = pc[i];
		buff[(i % 16) + 1] = '\0';
	}

	// Pad out last line if not exactly 16 characters.
	while ((i % 16) != 0) {
		printf("   ");
		i++;
	}

	// And print the final ASCII bit.
	printf("  %s\n", buff);
}

#ifdef __cplusplus
extern "C" {
#endif

int zpp_main(int argc, char *argv[], sgx_enclave_id_t global_eid);

uint64_t enclave_init() {
	uint64_t ret;
	ret = initialize_enclave();
	if (ret > 0) {
		//printf("Enclave initialized successfully with EID=%d.\n", ret);
	} else {
		printf("ret = %d.\n", ret);
		print_error_message((sgx_status_t)(ret * -1));
	}
	return ret;
}

#ifdef __cplusplus
}
#endif

void string2hex(const char input[], char buffer[], size_t size) {
	const char * pos = input;
	for (size_t count = 0; count < size && *pos != 0; count++) {
		sscanf(pos, "%2hhx", &buffer[count]);
		pos += 2;
	}
}

void injectRequest(const char input[], size_t len, long eid) {
	size_t buffersize = 8192;
	char buffer[buffersize];
	size_t psize = len;
	string2hex(input, buffer, buffersize);
	hexdump("input", buffer, psize);

	printf("Inject request: %lu Bytes. ", len);
	sgx_status_t ret = ecall_handle_input_from_client(eid, &psize, buffer, psize, buffersize, (int) eid);
	if (ret == SGX_SUCCESS) {
		printf("SUCCESS.\n");
	}
//	hexdump("output", buffer, psize);
}

void injectResponse(const char input[], size_t len, long eid) {
	size_t buffersize = 8192;
	char buffer[buffersize];
	size_t psize = len;
	string2hex(input, buffer, buffersize);
//	hexdump("input", buffer, psize);

	printf("Inject response: %lu Bytes. ", len);
	sgx_status_t ret = ecall_handle_input_from_zookeeper(eid, &psize, buffer, psize, buffersize, (int) eid);
	if (ret == SGX_SUCCESS) {
		printf("SUCCESS.\n");
	}
//	hexdump("output", buffer, psize);
}

// create /a test
const char createRequest[] =
		"14dcc13d01ce1c050938d471f87467c57359c237b79912cbbb32d4aae8c1683676bd5c810ac5277694643932e2d7b905c894e842ffd8e2bc9384b64cb4792e2d391ba4ab4100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t createRequestLen = 69;
const char createResponse[] =
		"00000001000000000000000200000000000000282f62544266656a357662637671396f77424a513839345a4671554e794668424e4d6665553377415500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t createResponseLen = 60;

// long create (1024 B payload)
const char createLongRequest[] =
		"14dcc1d901ce1c050938d47ef87615a01229d30df4b220f98333d4bae82492cc8c42d1148253b98c6e9ec5a976542c91576e12b80535961f99d91f80e5494c3fa70eb81aed325e51f3b2bee786fafbb61296f2314ff0798245e814083f79bf622539a63853f5ae95bae7f7dec8c4a03d0744df5f2cba13cbe99e9ce04467c0e9d59cceaaf75efdb08b40e70cbdca2345c203f962518604b4fbb5b00da24a4150a62bce690158a7a04c4f61351e0908c64935c1e8290bd4b8104089e5cf31d2151f0609c007dfc5f4fd14e4073787c84894cad7f9e81b7ec2bea64052c30be916ec6ea8edf736dfef999ac58efbacbb86a64123bbc89be70301bf0902a1ca5791b50eed72999292fab638ae491ff4422b3ab9d10f1a5c9a0d308115c14102a48705829ef986645cf51b4a508015a705b714bdef8c0b8fb3180d88e84ffaee54ad331ffb818a38456db4a79a59968a24593901a8e232ba9515988bb442147408d9cd1061c96f7122a9fbb6bb013b4710f39d2a6e3f4b6ab0e33f41e842afbcabbde8dfa1330a0ff12eeac5e1487bb1460ce77249bdc3282049b4fe92956d233a36f794be6d22b8417fc5e2cea2b0996c7a766d0953eed4803b20eef8cd66e2fd275fc8521115efdad804b5cf16be2e6c58ce2aea660a8fcb660f6a0f76979061dba319687b30f79e60422baac9f8938eb265b9d4d7b56e236a775d5126b6774c5a397e225e79e71b57429e22170b02ac74db0b885dd614790c9c2a760fa656b57a0fa1e3cdff8ba0a74b189fd25e512ce06869c9ae4bbbd8aa7a1e3bc74dc81ec59851ab33c17a0e194ecf8381a64fabb81c97d247d179c965035d1d91d34eabdd23db70c7f22bc1da61e7cb12e93463e4433c6061775bbdb935944999d2f8ea209b2d0c331a56da613fb94ce4b30dc842817b68f39a9ea667bcca674c9b56466c42e1fe59bb02ce92fe75d2788b67c5bc669e45fa801b1533805ea9e1bcf76b527dc3826986c8dec2c09eb7d0057497f3f36eda18a48117aca280cdcdbb6334ff9faedc626031e778907e924455b5fa809a4048e2ac489bd66a9e63b6c37a38e0a0c598218c2fcf9dc84b51125bdb10f37eb087dfa51d51aee9055abdbacb7dfe3212a0d6ad96f4713ca02ababb8bf599c5fd928f3b87c8041399660b7c8bb109f95244928b8c3baedd77dbbc0410f72f97811f1b4b49e0539915c483cc5cc8024a7e2bf925e4b85a9d6eb33f0b638becbed9c27cdf1afba968404930ad4b0fc89a6e78ca26a27b5131b0bb969129395fa8486b87dac96a891bc1ee4c2fd79369cfcc344e1600314a614ff11ac58dc80a82d638f01c7b1e509c31bd0cfa36ed8c894aaa3fe789b4f8ce40f9e0903c4ee3456ebe0d2d37d0d18a1aec0cc759af9dd950214406dc8b31aa1712ecda9ebe684107bc7f0f61324d4689ae3365929bc184fb5d0770950aae70283f426958dd2a32bb12642d1c4153752f1a2163ed6e32ef874e035ce13ef333ccfda96fb23c6cc1f7c86a7e293dff8e6f231b7481517d29262321bcc6cbb6e6796ad0b24d8d66778d1689f4a8b2d54fe09d048ef633125b98512228dc3ea0350baf6a98180c5b5a4df828a90a1da81efd1345e51ef903d57326abdbee1a10e2f3c8987deaab0e9760cbcbf843400af3fa29bf34d47b4d5e9d9b229a38e2bb4c4118975cdf6a5d4c865a16174ba391a07a6390f25209f70b7b81c1dcd3897a66f3793b037a1d320eaaca866e881f4d44fc0100841825a13d8288c37ba5176c41ea8decc2c72f9564a514f0d4414addb71402dc9f8486e3eeb9b9428848011d40c13248c39792b7f90f7bb909969dd8f3e67528cff39cd6129b35e3c4d0e3882ee8f65614fcec408ff15603740b715c0611e86a38add72510a9a086afcd2b3a529f20e10d04ad18deb0f0dab4fcb48a1661c73e30f5a23069e85f129b99e816aeab8fc7c39f41e30e7a70a0def4b1469a35e7ee736aea81b4624b63415c715816f6e210e2fc224a3560d5ff56a382e430d52150bb5c97877a9b1115fbba42f6aa6558c8064490323ce8415607b01e6fed31e4b7db23e307cd64f2f8bcce8ed04867b607d022c6724cf04dde098ef4b67a6a7b7d968581af2cf534aeb8c5f06db06df78dc568eea603e94b176b0408248e9bef017e60dcf411ca00ec7bdf7ac660a75f60d244289aa61d1e7fd90ff027850bec18bfeac5c6dea9e3de74b90f1a6c4ddaa30a17681e951516071835c153364547c64d2adbb1b9f1172a1966626b25b2888ceba7f16ed86e4fcfd90bc8fc260896d5a02d95a89cc6fa84f96d56f93422964cadedcfbdcb388a87636b57ff656c2e75533fd0c51333ce299c0346dd1a0c55396f85204e82f11c093a24bf951cc5dd7124fc0b06f2c1bbde27de5538a531db9fa47331207a22882932aa622e0abedd66f29508aa58c778e41e787fe3472925da04ae3a8dfa4ae7edb652b902f5c007c85d6b77ee6027cd9bd9ef4fe180dfbf504a54c70d4c93372d7f0ec6a4373f192e4dcd370eff40b4a83bf3bf9f774953288ea4a5a4f5a688f0af3e1d58b09dcdbe1fce172e0fe30c5ea8b52187e34846c75b8650dad2559d0c88057feb049617773331ff41a7849a311e90a3dec5e20c73199ff832dd44efcd909dff4d4d81e38c92042a59a7936d64c0b0a57e7fb55033f34f52dc46ecd4f2df6e362d8aa6b9384a591e9b0c1ba55d42418d6498f353cfec6f5b39bda7da5a156fc6436f4c62491977ccf31449caaf0541896cd04a1e5a3b5d6fcfa97568c5dd4a82b5a564e02bbf691d5f65c972666dc223c687252acc9701b29d859df8fa9faeb3e2eb29b3494f2d380c238d131ab26841e05eb300583fdc9b08b10115a9a82230b32e8b281eafc4ffc1e1b7b8363f6d630aacfc44d3ee7985787bfb27b69ccf43081db081a56b267263cf0f4921d8ec644c14d2088e7ad372866dafefb732ed081e2dcd6475e8d7c8a355d2dfb68f24e546b3ec40920d1a56ee153bee3b007bb3f5db04df38ca4d43651f840a533bcae57817f74b6da68fc0122636e5cfa5bca600bd507e36ff24326f06d41dc42312f02a971fb4bbde8886644c5461014dd7c6e1ae873a581fa808898b907fc81b6c80da3bcd85ef6b3d3f0da458cca8c8321ffdbd5fe89da31a7b5a8e03d61dca89dbb3a99f1d42773062097d9a76c8eff3d3ca77d8c4fdc9d3b892fd8ef3f64d977078e03e2b7f20b38b9f4b5f674a3ff8578a068d37a43b1cb98351572449f780b95d51d27cdeb71d5011391cd974abb1393d569ff15f89ede69c9f17745ed76bab498e61bc1a989f232fef38ffdb0741c58cfd718562d5d3578455299cebc8617b4be29da4f9b9f462d4aedf1fd65b06d997730e0bfa62cd973213d0c59ed137e800886bcbcb5ff74159c91659a094ea975cdac29ff6c74cb652efa706d92bb55a61c192adea6316bf040439610418239275818b3918c6561253d16118aa1c8c924fa369755289f90c8713c62c46efac9105d15da4a4e4bbc950419adfb503fe5a07f5645f46d46b89272228182e9e6a94506bea3bde4142b7846c092cbb547e6445956d357349bb59d4300f1feac0af6ed83a7b612779daf973b39d216a4d35d1ce7a66078068dfd8e2b86292d77bd717711ff38677128300129762049667fc91b85fcb1c582f6ca62178ae350f5183a041293561ff1851ecd3376518ae2c9702f4a484a1e31f04c785f8bf28faf11234432d5764102342ed00dd1da5e9b9a13ed60f254bb2f661d70dcdf8c52234b71b10439290726ea10acfc74bee0f386c78818ebcf1a99a2762f6c36e1093f86c8dce6cf5f5345571a2a098f1f7d2a24aeaabfc0bb6b32c202df57e410acadbc25280127ced946ba1b646c226b8caa371a8428dc96776f156af89ba29ccbf2ee7b1983ca9babbf2d89ff00784b9aa177392c5d4ce1612bbf8e5af2499cc97baf1b1a771b9ed5df241252a9afdb6dbcffcb9a26e08f5ee043edc0b7282cc80b55b53070e5a3c5b053b5ad24040ef6d8d3447996702463418cb65e907fc9077731d90e7d68b7918a3d3f2d8df976299698f5c0af1824385f2a8d860499bc5d863dd01aae45734a90a2100e902490ba877eb9cd4fce7f6210a36b2bef9ce2926493ab50b460ff6db0abe3c26de0095aad23ddf0ead660d492d61dcc23f12e541d1def569f93750672a7a2f099ee599df1161a925954998855b73cb4b211e295bd27e68f7cec54d91d4801ca6dc3f63b02410e33b2c6a9edac2f0fdbec257d372c68c81dbc8be0f3bce7d69b01809c7368cddd8aadc6d6cfadec667cf6e25cbb23db200c25470f6414818b2e3e8b899834a360a6aec61acc99b26f0e4607befb98f755f58fb83fa5f79a51595ca92bc1250b45214864cb719a8f0149e9d55a5d1272b98cdffc2f1c8f2ee4ec90b019c85c55c0e627183be4eaefe6fb8742d1f562e44582c583c37abf5bff323f949a12c74ab24dc9eb2dc89aefa6be45ad5c37c36c0e66ddc4388357c21edcb25d8c2a07968eb7d5c68fcbd48866f6e51369ccb7e2d146bfaa9c0d1c41a0b4cb9c6f558d8a2cd8125475824f6b835193f7e3f885485adf701897df8bdd90cb511788f30f27760bc9a693757e1601c99a14bd9e825601c1223c00519123479614b36105bb83c45314deabeabdc362f5b9840393ababee3ebb94636c15ce617374988d472094e4d6903b8fbae6ad54f834e3a5469e1530069cb1ad7ab1121f75405d14009e526965d22480b277d9bc829d91950a5c224493b5c9c8df022378f4692293c0f3dfa343e97b5d05b1143cce3213c984b128609fa13580aba9089a49e53c565d249390f12c589fc5c6bb22fbf39179ec72a4f8fe223a9e80fad54f6d96c2a416d79daf4a83d5eab450dba18b0ec0236092763c83140be2da6a70234ba1c354e6cb4fbdf232a22284785519faf8c627634f57ff28b3e2625b963e589d4520591c34ca260171390f4a8f9589e3a9e6553c6f795887c519bb39a6c4b97cc39fe5d0318d0f4d492c70433cb3ab64a21a9c59653aece3170ae8a1be67e321df9ae043cd488e545a989cc3592487fe9a20cf04c45e3847c1ff857b5807370ce029ec069fcab07148995dfd72b4327e8c5dfeea4c693ab3e4f62a715668e23d18b6b62f9f056fd0773c11e1aa8f46a957f96f7d6f47ced93f7deed0ea2aa14de52b72a81516a3aa084a1551f5d4172334f56398490e3db70f62d5ac11e935f8d0d0a99a9bcbade6e1355b117c76de0a576d24e500cf9e8a61a4d09bc15a671c4cc12baf90795c9a6a03c8fbcfa9125848c2057add16c85c9e38e52c10987ac7cdaeaf262e73ab5d0ae84e6437f3e682345c28232884ef131bcbf6f52be9906029ae8d28e3860590146316abd70f6c7505d8391d8855772f157b9278aa7a757299eadb1587de52dec8622d890fc28720f4841e8d7fa869d34a9100c399942b89b775a8790312bceeb626c3f24b5e9f852ee2dc43f8cb7e4aeaee0f929ecc48117ea3f92ebf58930172d9a096bc9e921fd464fe828907b2a5e93a9a967d3c76ef678d8542c5a05c2375864dcb0cf1b80b832da9a86df1f54310a2435784146517f1f1f1b5e175a7e64be5c44a2abafb3615afdd09b352e3e676ff4ff6b896b9d9062fa3ba24714053f38cbffe5d9fb133afa56791ef1e69f8421a0274bea95807f002e1671ce1e24671c793276d55e1c24f2cdb55b599ef86408bb6f1c2ecabd30133aa53668598f1fb303afbe90876444b7af45f7e7cdf74de25b59c44655bc725dc0558f380ec1ad46cc9b57902a74f548537cf3024e2a89ae27ddad69e4313fd0b2498f736ff6a55403c1ae5f655b4ee283661d0156dbfabff44b62fd32ea9ea249450c837fa70cd6deb9350000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t createLongRequestLen = 4172;
const char createLongResponse[] =
		"000000e500000000000000e600000000000000372f6a41586e574e55503742645474777047594347366642727a4c4a4250574c472d455852615650716d4761656c51324337677957674f4100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t createLongResponseLen = 75;

// get /a
const char getRequest[] =
		"14dcc13e01ce1c000938d471f87467377b8ce043b4880d8798212ecb473803000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t getRequestLen = 31;
const char getResponse[] =
		"000000020000000000000002000000000000003460b9b2486b9ec0818d2b980e3222a7c05cab64647b6a519e5b631dafcb3eadc95cec11c6a5869d8e678ac2e2bd8e858434ddb2d30000000000000002000000000000000200000154f1be3a3d00000154f1be3a3d0000000000000000000000000000000000000000000000340000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t getResponseLen = 140;

// set /a hallo
const char setRequest[] =
		"14dcc13f01ce1c010938d471f87467c57358de33a8817d3444cc2b9132e73a806835d1957921ae4e65285a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t setRequestLen = 43;
const char setResponse[] =
		"000000030000000000000003000000000000000000000002000000000000000300000154f1be3a3d00000154f1be907e00000001000000000000000000000000000000000000003500000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t setResponseLen = 84;

// delete /a
const char deleteRequest[] =
		"14dcc13801ce1c060938d471f874983a8ca2a6b1b95f322600e3ecaacde31732a814000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t deleteRequestLen = 34;
const char deleteResponse[] =
		"00000004000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t deleteResponseLen = 30;

// ls /
const char lsRequest[] =
		"14dcc13a01ce1c0c0938d472f815ec7d220ae817d0d67d9d8b0c8659b2fa00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t lsRequestLen = 30;
const char lsResponse[] =
		"0000000600000000000000040000000000000001000000097a6f6f6b656570657200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
size_t lsResponseLen = 33;

long eid;

void all(long eid) {
	// create
	printf("create.\n");
	injectRequest(createRequest, createRequestLen, eid);
	injectResponse(createResponse, createResponseLen, eid);

	// get
	printf("get.\n");
	injectRequest(getRequest, getRequestLen, eid);
	injectResponse(getResponse, getResponseLen, eid);

	// set
	printf("set.\n");
	injectRequest(setRequest, setRequestLen, eid);
	injectResponse(setResponse, setResponseLen, eid);

	// delete
	printf("delete.\n");
	injectRequest(deleteRequest, deleteRequestLen, eid);
	injectResponse(deleteResponse, deleteResponseLen, eid);

	// ls
	printf("ls.\n");
	injectRequest(lsRequest, lsRequestLen, eid);
	injectResponse(lsResponse, lsResponseLen, eid);

	// create long
	printf("create 4KB.\n");
	injectRequest(createLongRequest, createLongRequestLen, eid);
	injectResponse(createLongResponse, createLongResponseLen, eid);
}

typedef enum types {
	create, get, set, del, ls, lng
} types_t;

#define REQNUM 200
sem_t sem;

void responses(types_t type) {
	for (int i = 0; i < REQNUM; ++i) {

		sem_wait(&sem);

		switch (type) {
		case create:
			injectResponse(createResponse, createResponseLen, eid);
			break;
		case get:
			injectResponse(getResponse, getResponseLen, eid);
			break;
		case set:
			injectResponse(setResponse, setResponseLen, eid);
			break;
		case del:
			injectResponse(deleteResponse, deleteResponseLen, eid);
			break;
		case ls:
			injectResponse(lsResponse, lsResponseLen, eid);
			break;
		case lng:
			injectResponse(createLongResponse, createLongResponseLen, eid);
			break;
		}
	}
}

void requests(types_t type) {
	for (int i = 0; i < REQNUM; ++i) {
		switch (type) {
		case create:
			injectRequest(createRequest, createRequestLen, eid);
			break;
		case get:
			injectRequest(getRequest, getRequestLen, eid);
			break;
		case set:
			injectRequest(setRequest, setRequestLen, eid);
			break;
		case del:
			injectRequest(deleteRequest, deleteRequestLen, eid);
			break;
		case ls:
			injectRequest(lsRequest, lsRequestLen, eid);
			break;
		case lng:
			injectRequest(createLongRequest, createLongRequestLen, eid);
			break;
		}

		sem_post(&sem);
	}
}

void threaded() {
	pthread_t t1, t2;
	printf("starting threads.\n");
	sem_init(&sem, 0, 0);
	pthread_create(&t1, NULL, (void*(*)(void*))requests, (void*)lng);
	pthread_create(&t2, NULL, (void*(*)(void*))responses, (void*)lng);
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	sem_destroy(&sem);
	printf("thread joined.\n");
}

int SGX_CDECL main(int argc, char *argv[])
{
	// init enclave
	printf("Initialize enclave ...\n");
	eid = enclave_init();
	if (eid < 0) {
		printf("error during enclave init, eid=%ld.\n", eid);
		abort();
	}

	// injection
//	printf("All captured buffers\n");
//	all(eid);

// threaded
	printf("Threaded requests, responses.\n");
	threaded(); // max. 260KB

	return 0;
}

